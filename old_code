
#OAUTH METHOD
  # def self.find_for_facebook_oauth(auth, signed_in_resource=nil)
  #   user = User.where(:provider => auth.provider, :uid => auth.uid).first
  #   unless user
  #     user = User.create(  name:auth.extra.raw_info.name,
  #                          provider:auth.provider,
  #                          uid:auth.uid,
  #                          email:auth.info.email,
  #                          password:Devise.friendly_token[0,20],
  #                          terms: 't',
  #                          city:auth.info.location
  #                          )
  #   end
  #   user
  # end

# https://github.com/pantulis/devise-omniauth-only-twitter/blob/master/app/models/user.rb

  # has_many :authentications
  
  # def self.find_for_twitter_oauth(omniauth)
  #   authentication = Authentication.find_by_provider_and_uuid(omniauth['provider'], omniauth['uid'])
  #   if authentication && authentication.user
  #     authentication.user
  #   else
  #     user = User.create!(:nickname => omniauth['nickname'], 
  #                           :name => omniauth['name'])
  #     user.authentications.create!(:provider => omniauth['provider'], :uuid => omniauth['uid'])
  #     user.save
  #     user
  #   end
  # end


#OLDER EVENT SERVING FOR ROLL YOUR OWN
  # def events_on_date(load_date)
  #   #usable_date = load_datetime.in_time_zone("Central Time (US & Canada)")
  #   # usable_date = load_datetime# - 4.hours
  #   # adjusted_load_date = usable_date.to_date

  #   @my_events = self.events
  #   @date_events = []
  #   @my_events.each do |e|
  #     if e.starts_at.to_date == load_date
  #       e.inviter_id = self.id
  #       @date_events.push(e)
  #     end
  #   end

  #   @plans = self.plans
  #   @date_plans = []
  #   @plans.each do |p|
  #     if p.starts_at.to_date == load_date
  #       p.inviter_id = self.id
  #       @date_plans.push(p)
  #     end
  #   end

  #   @invitations = Invite.where('invites.email = :current_user_email', current_user_email: self.email)

  #   @toggled_invitation_events = []
  #   @invitations.each do |i|
  #     @ie = Event.find_by_id(i.event_id)
  #     if @ie.starts_at.to_date == load_date
  #       unless self.rsvpd?(@ie)
  #         if self.following?(@ie.user)
  #           if self.relationships.find_by_followed_id(@ie.user).toggled?
  #             @ie.inviter_id = @ie.user_id
  #             @toggled_invitation_events.push(@ie)
  #           end
  #         else
  #           @ie.inviter_id = i.inviter_id
  #           @toggled_invitation_events.push(@ie)
  #         end
  #       end
  #     end
  #   end

  #   @date_ideas = []
  #   @toggled_followed_users = User.joins('INNER JOIN relationships ON users.id = relationships.followed_id')
  #                                   .where('relationships.follower_id = :current_user_id AND 
  #                                     relationships.toggled = true AND relationships.confirmed = true',
  #                                     :current_user_id => self.id) 

  #   @toggled_followed_users.each do |f|
  #     f.plans.each do |fp| #for friends of friends events that are RSVPd for
  #       if fp.starts_at.to_date == load_date
  #         unless fp.full? || fp.visibility == "invite_only" || self.rsvpd?(fp) || self.invited?(fp)
  #           if fp.user == f || fp.visibility == "friends_of_friends"
  #             fp.inviter_id = f.id
  #             @date_ideas.push(fp)
  #           end
  #         end
  #       end
  #     end
  #   end

  #   @morning_events_on_date = @date_ideas | @toggled_invitation_events | @date_plans | @date_events

  #   @morning_events_on_date.select do |e|
  #     e.starts_at.utc < load_date.to_s + " 17:00:00"
  #   end
  #   return @morning_events_on_date

  # end

  # def morning_plans_on_date(load_date)
  #   @plans = self.plans
  #   @morning_plans = []
  #   @plans.each do |p|
  #     if p.starts_at.to_date == load_date
  #       if p.starts_at.utc < load_date.to_s + " 17:00:00"
  #         @morning_plans.push(p)
  #       end
  #     end
  #   end
  #   return @morning_plans
  # end

  # def afternoon_plans_on_date(load_date)
  #   @plans = self.plans
  #   @afternoon_plans = []
  #   @plans.each do |p|
  #     if p.starts_at.to_date == load_date
  #       if p.starts_at.utc >= load_date.to_s + " 17:00:00" && p.starts_at.utc < load_date.to_s + " 23:00:00"
  #         @afternoon_plans.push(p)
  #       end
  #     end
  #   end
  #   return @afternoon_plans
  # end

  # def evening_plans_on_date(load_date)
  #   @plans = self.plans
  #   @evening_plans = []
  #   @plans.each do |p|
  #     if p.starts_at.to_date == load_date
  #       if  p.starts_at.utc >= load_date.to_s + " 23:00:00"
  #         @evening_plans.push(p)
  #       end
  #     end
  #   end
  #   return @evening_plans
  # end

  # def morning_maybes_on_date(load_date)
  #   @invitation_events = Event.joins('INNER JOIN invites ON events.id = invites.event_id')
  #                               .where('invites.email = :current_user_email', current_user_email: self.email)
  #   @toggled_morning_invitation_events = []

  #   @invitation_events.each do |ie|
  #     if fp.starts_at.to_date == load_date
  #       if fp.starts_at < load_date.to_s + " 12:00:00"
  #         unless self.rsvpd?(ie) || self == ie.user
  #           if self.following?(ie.user)
  #             if self.relationships.find_by_followed_id(ie.user).toggled?
  #               @toggled_morning_invitation_events.push(ie)
  #             end
  #           else
  #             @toggled_morning_invitation_events.push(ie)
  #           end
  #         end
  #       end
  #     end
  #   end

  #   @morning_maybe_events = []
  #   @toggled_followed_users = User.joins('INNER JOIN relationships ON users.id = relationships.followed_id')
  #                                   .where('relationships.follower_id = :current_user_id AND 
  #                                     relationships.toggled = true AND relationships.confirmed = true',
  #                                     :current_user_id => self.id) 

  #   @toggled_followed_users.each do |f|
  #     f.plans.each do |fp| #for friends of friends events that are RSVPd for
  #       if fp.starts_at.to_date == load_date
  #         if fp.starts_at < load_date.to_s + " 12:00:00"
  #           unless fp.full? || fp.visibility == "invite_only" || self.rsvpd?(fp)
  #             if fp.user == f || fp.visibility == "friends_of_friends"
  #               @morning_maybe_events.push(fp)
  #             end
  #           end
  #         end
  #       end
  #     end
  #   end

  #   @morning_maybes_on_date = @morning_maybe_events | @toggled_morning_invitation_events
  #   return @morning_maybes_on_date

  # end

  # def afternoon_maybes_on_date(load_date)
  #   @invitation_events = Event.joins('INNER JOIN invites ON events.id = invites.event_id')
  #                               .where('invites.email = :current_user_email', current_user_email: self.email)
  #   @toggled_afternoon_invitation_events = []

  #   @invitation_events.each do |ie|
  #     if fp.starts_at.to_date == load_date
  #       if fp.starts_at >= load_date.to_s + " 12:00:00" && fp.starts_at < load_date.to_s + " 18:00:00"
  #         unless self.rsvpd?(ie) || self == ie.user
  #           if self.following?(ie.user)
  #             if self.relationships.find_by_followed_id(ie.user).toggled?
  #               @toggled_afternoon_invitation_events.push(ie)
  #             end
  #           else
  #             @toggled_afternoon_invitation_events.push(ie)
  #           end
  #         end
  #       end
  #     end
  #   end

  #   @afternoon_maybe_events = []
  #   @toggled_followed_users = User.joins('INNER JOIN relationships ON users.id = relationships.followed_id')
  #                                   .where('relationships.follower_id = :current_user_id AND 
  #                                     relationships.toggled = true AND relationships.confirmed = true',
  #                                     :current_user_id => self.id) 

  #   @toggled_followed_users.each do |f|
  #     f.plans.each do |fp| #for friends of friends events that are RSVPd for
  #       if fp.starts_at.to_date == load_date
  #         if fp.starts_at >= load_date.to_s + " 12:00:00" && fp.starts_at < load_date.to_s + " 18:00:00"
  #           unless fp.full? || fp.visibility == "invite_only" || self.rsvpd?(fp)
  #             if fp.user == f || fp.visibility == "friends_of_friends"
  #               @afternoon_maybe_events.push(fp)
  #             end
  #           end
  #         end
  #       end
  #     end
  #   end

  #   @afternoon_maybes_on_date = @afternoon_maybe_events | @toggled_afternoon_invitation_events
  #   return @afternoon_maybes_on_date

  # end

  # def evening_maybes_on_date(load_date)
  #   @invitation_events = Event.joins('INNER JOIN invites ON events.id = invites.event_id')
  #                               .where('invites.email = :current_user_email', current_user_email: self.email)
  #   @toggled_evening_invitation_events = []

  #   @invitation_events.each do |ie|
  #     if fp.starts_at.to_date == load_date
  #       if fp.starts_at >= load_date.to_s + " 18:00:00"
  #         unless self.rsvpd?(ie) || self == ie.user
  #           if self.following?(ie.user)
  #             if self.relationships.find_by_followed_id(ie.user).toggled?
  #               @toggled_evening_invitation_events.push(ie)
  #             end
  #           else
  #             @toggled_evening_invitation_events.push(ie)
  #           end
  #         end
  #       end
  #     end
  #   end

  #   @evening_maybe_events = []
  #   @toggled_followed_users = User.joins('INNER JOIN relationships ON users.id = relationships.followed_id')
  #                                   .where('relationships.follower_id = :current_user_id AND 
  #                                     relationships.toggled = true AND relationships.confirmed = true',
  #                                     :current_user_id => self.id) 

  #   @toggled_followed_users.each do |f|
  #     f.plans.each do |fp| #for friends of friends events that are RSVPd for
  #       if fp.starts_at.to_date == load_date
  #         if fp.starts_at >= load_date.to_s + " 18:00:00"
  #           unless fp.full? || fp.visibility == "invite_only" || self.rsvpd?(fp)
  #             if fp.user == f || fp.visibility == "friends_of_friends"
  #               @evening_maybe_events.push(fp)
  #             end
  #           end
  #         end
  #       end
  #     end
  #   end

  #   @evening_maybes_on_date = @evening_maybe_events | @toggled_evening_invitation_events
  #   return @evening_maybes_on_date
  # end

  # def plans_on_date(load_datetime)
  #   #usable_date = load_datetime.in_time_zone("Central Time (US & Canada)")
  #   # usable_date = load_datetime# - 4.hours
  #   # adjusted_load_date = usable_date.to_date

  #   @plans = self.plans
  #   @date_plans = []
  #   @plans.each do |p|
  #     if p.starts_at.to_date == load_datetime.to_date
  #       @date_plans.push(p)
  #     end
  #   end
  #   return @date_plans
  # end

  # def ideas_on_date(load_datetime)
  #   #This is to make sure the date matches the local date
  #   #usable_date = load_datetime.in_time_zone("Central Time (US & Canada)")
  #   # usable_date = load_datetime# - 4.hours
  #   # adjusted_load_date = usable_date.to_date

  #   @invitation_events = Event.joins('INNER JOIN invites ON events.id = invites.event_id')
  #                               .where('invites.email = :current_user_email', current_user_email: self.email)
  #   @toggled_invitation_events = []

  #   @invitation_events.each do |ie|
  #     if ie.starts_at.to_date == load_datetime.to_date
  #       unless self.rsvpd?(ie)
  #         if self.following?(ie.user)
  #           if self.relationships.find_by_followed_id(ie.user).toggled?
  #             @toggled_invitation_events.push(ie)
  #           end
  #         else
  #           @toggled_invitation_events.push(ie)
  #         end
  #       end
  #     end
  #   end

  #   @date_ideas = []
  #   @toggled_followed_users = User.joins('INNER JOIN relationships ON users.id = relationships.followed_id')
  #                                   .where('relationships.follower_id = :current_user_id AND 
  #                                     relationships.toggled = true AND relationships.confirmed = true',
  #                                     :current_user_id => self.id) 

  #   @toggled_followed_users.each do |f|
  #     f.plans.each do |fp| #for friends of friends events that are RSVPd for
  #       if fp.starts_at.to_date == load_datetime.to_date
  #         unless fp.full? || fp.visibility == "invite_only" || self.rsvpd?(fp)
  #           if fp.user == f || fp.visibility == "friends_of_friends"
  #             @date_ideas.push(fp)
  #           end
  #         end
  #       end
  #     end
  #   end

  #   return @date_ideas | @toggled_invitation_events

  # end



  htmlEscape(event.host_pic) +



No following maybes    
    @events = Event.all
    @maybe_events = [] #an empty array to fill with relevant events

    #take main list and remove already RSVP'd events
    @events.each { |e|
      plan = false
      unless(e.full?)
        if(e.tipped?)
          e.guests.each{ |g|
            if g == current_user
             plan = true
            end
          }
          if e.user == current_user
            plan = true
          end
          if plan == false
            @maybe_events.push(e)
          end
        end  
      end
    }
    @events = @maybe_events


    class AddFbPictureToUsers < ActiveRecord::Migration
  def change
    add_column :users, :fb_picture, :string
    add_column :users, :fb_token, :string
  end
end



show details of daily events with this

$(.dayDetails).hide();

$('.day').hover(function(){
  $(this).next('.dayDetails').show();
  },
  $(this).next('.dayDetails').hide();
});

$(.eventDetails).hide();
$('.event').hover(function(){
  $(this)next('.eventDetails').show();
  },
  $(this).next('eventDetails').hide();
});

overlay for new event form could be with a toggle call

$('new_event_button').toggle(function(){
  $(#new_event_form).show(); // with overlay jquery formatting
  },
  $(#new_event_form).hide();
)};


add qTip to event for deets

http://arshaw.com/fullcalendar/docs/event_rendering/eventRender/

    eventRender: function(event, element) {
        element.qtip({
            content: event.description
        });
    }


<div id="recaptcha"><%= recaptcha_tags display: { theme: 'white' }, ajax: true %></div>



#For Refactoring Invites to be unconfirmed RSVPs
  
  # def min
  #   if min == nil
  #     min = 1
  #   end
  # end

  # def max
  #   if max == nil
  #     max = 10000
  #   end
  # end

  # def confirmed_guests
  #     User.joins('INNER JOIN rsvps ON users.id = rsvps.guest_id').
  #           where('rsvps.plan_id = :event_id AND rsvps.confirmed = "t"',
  #               :event_id => self.id)
  # end

  # def invited_guests
  #       #maybe try searchign RSVP table for user/event combo and check if true
  #     User.joins('INNER JOIN rsvps ON users.id = rsvps.guest_id').
  #           where('rsvps.plan_id = :event_id AND rsvps.confirmed = "f"',
  #               :event_id => self.id)
  # end



FB events

upon sign up from facebook (omniauth_controller)
add method create_fb_events

in events model:

  def create_fb_events

    @graph.get_connections("me", "events")
    @graph.get_connections("me", "invitations")?

    [{"name"=>"Housewarming Party",
  "start_time"=>"2012-08-25T14:00:00-0500",
  "end_time"=>"2012-08-25T22:00:00-0500",
  "timezone"=>"America/Chicago",
  "location"=>"8954 Sunstone Ln Middleton, WI 53562",
  "id"=>"316821768413401",
  "rsvp_status"=>"attending"}]


  create dummy facebook user

  call asynchronously to get the events and invites 
    on each
      Check that they have start TIME
      if true
      Check on fb_id if events are already there
      if false
      determin the event's owner & privacy
        @graph.get_object("415061778552519")
        lookup host from hi's users by fb_id
        if present - create event with user as host and visibility
        else - create event with set fb_dummy is host and visibility
      create net new events and either RSVP or invite the user (if the events have start times)
  end

    create job to check at night if users should replace fb_dummy
      get all events from facebook using fb_event_id
      If owner = current_user && current owner = fb_dummy
        Then replace fb_dummy with current_user as owner of event


